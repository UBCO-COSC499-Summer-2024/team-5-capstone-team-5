{"ast":null,"code":"import React, { useEffect, useLayoutEffect, createContext, useContext, useMemo, useRef, createElement } from 'react'; // Shared state between server components and client components\n\nconst noop = () => {}; // Using noop() as the undefined value as undefined can be replaced\n// by something else. Prettier ignore and extra parentheses are necessary here\n// to ensure that tsc doesn't remove the __NOINLINE__ comment.\n// prettier-ignore\n\n\nconst UNDEFINED =\n/*#__NOINLINE__*/\nnoop();\nconst OBJECT = Object;\n\nconst isUndefined = v => v === UNDEFINED;\n\nconst isFunction = v => typeof v == 'function';\n\nconst mergeObjects = (a, b) => ({ ...a,\n  ...b\n});\n\nconst isPromiseLike = x => isFunction(x.then); // use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\n\n\nconst table = new WeakMap(); // counter of the key\n\nlet counter = 0; // A stable hash implementation that supports:\n// - Fast and ensures unique hash properties\n// - Handles unserializable values\n// - Handles object key ordering\n// - Generates short results\n//\n// This is not a serialization function, and the result is not guaranteed to be\n// parsable.\n\nconst stableHash = arg => {\n  const type = typeof arg;\n  const constructor = arg && arg.constructor;\n  const isDate = constructor == Date;\n  let result;\n  let index;\n\n  if (OBJECT(arg) === arg && !isDate && constructor != RegExp) {\n    // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n    // If it's already hashed, directly return the result.\n    result = table.get(arg);\n    if (result) return result; // Store the hash first for circular reference detection before entering the\n    // recursive `stableHash` calls.\n    // For other objects like set and map, we use this id directly as the hash.\n\n    result = ++counter + '~';\n    table.set(arg, result);\n\n    if (constructor == Array) {\n      // Array.\n      result = '@';\n\n      for (index = 0; index < arg.length; index++) {\n        result += stableHash(arg[index]) + ',';\n      }\n\n      table.set(arg, result);\n    }\n\n    if (constructor == OBJECT) {\n      // Object, sort keys.\n      result = '#';\n      const keys = OBJECT.keys(arg).sort();\n\n      while (!isUndefined(index = keys.pop())) {\n        if (!isUndefined(arg[index])) {\n          result += index + ':' + stableHash(arg[index]) + ',';\n        }\n      }\n\n      table.set(arg, result);\n    }\n  } else {\n    result = isDate ? arg.toJSON() : type == 'symbol' ? arg.toString() : type == 'string' ? JSON.stringify(arg) : '' + arg;\n  }\n\n  return result;\n}; // Global state used to deduplicate requests and store listeners\n\n\nconst SWRGlobalState = new WeakMap();\nconst EMPTY_CACHE = {};\nconst INITIAL_CACHE = {};\nconst STR_UNDEFINED = 'undefined'; // NOTE: Use the function to guarantee it's re-evaluated between jsdom and node runtime for tests.\n\nconst isWindowDefined = typeof window != STR_UNDEFINED;\nconst isDocumentDefined = typeof document != STR_UNDEFINED;\n\nconst hasRequestAnimationFrame = () => isWindowDefined && typeof window['requestAnimationFrame'] != STR_UNDEFINED;\n\nconst createCacheHelper = (cache, key) => {\n  const state = SWRGlobalState.get(cache);\n  return [// Getter\n  () => !isUndefined(key) && cache.get(key) || EMPTY_CACHE, // Setter\n  info => {\n    if (!isUndefined(key)) {\n      const prev = cache.get(key); // Before writing to the store, we keep the value in the initial cache\n      // if it's not there yet.\n\n      if (!(key in INITIAL_CACHE)) {\n        INITIAL_CACHE[key] = prev;\n      }\n\n      state[5](key, mergeObjects(prev, info), prev || EMPTY_CACHE);\n    }\n  }, // Subscriber\n  state[6], // Get server cache snapshot\n  () => {\n    if (!isUndefined(key)) {\n      // If the cache was updated on the client, we return the stored initial value.\n      if (key in INITIAL_CACHE) return INITIAL_CACHE[key];\n    } // If we haven't done any client-side updates, we return the current value.\n\n\n    return !isUndefined(key) && cache.get(key) || EMPTY_CACHE;\n  }];\n} // export { UNDEFINED, OBJECT, isUndefined, isFunction, mergeObjects, isPromiseLike }\n;\n/**\n * Due to the bug https://bugs.chromium.org/p/chromium/issues/detail?id=678075,\n * it's not reliable to detect if the browser is currently online or offline\n * based on `navigator.onLine`.\n * As a workaround, we always assume it's online on the first load, and change\n * the status upon `online` or `offline` events.\n */\n\n\nlet online = true;\n\nconst isOnline = () => online; // For node and React Native, `add/removeEventListener` doesn't exist on window.\n\n\nconst [onWindowEvent, offWindowEvent] = isWindowDefined && window.addEventListener ? [window.addEventListener.bind(window), window.removeEventListener.bind(window)] : [noop, noop];\n\nconst isVisible = () => {\n  const visibilityState = isDocumentDefined && document.visibilityState;\n  return isUndefined(visibilityState) || visibilityState !== 'hidden';\n};\n\nconst initFocus = callback => {\n  // focus revalidate\n  if (isDocumentDefined) {\n    document.addEventListener('visibilitychange', callback);\n  }\n\n  onWindowEvent('focus', callback);\n  return () => {\n    if (isDocumentDefined) {\n      document.removeEventListener('visibilitychange', callback);\n    }\n\n    offWindowEvent('focus', callback);\n  };\n};\n\nconst initReconnect = callback => {\n  // revalidate on reconnected\n  const onOnline = () => {\n    online = true;\n    callback();\n  }; // nothing to revalidate, just update the status\n\n\n  const onOffline = () => {\n    online = false;\n  };\n\n  onWindowEvent('online', onOnline);\n  onWindowEvent('offline', onOffline);\n  return () => {\n    offWindowEvent('online', onOnline);\n    offWindowEvent('offline', onOffline);\n  };\n};\n\nconst preset = {\n  isOnline,\n  isVisible\n};\nconst defaultConfigOptions = {\n  initFocus,\n  initReconnect\n};\nconst IS_REACT_LEGACY = !React.useId;\nconst IS_SERVER = !isWindowDefined || 'Deno' in window; // Polyfill requestAnimationFrame\n\nconst rAF = f => hasRequestAnimationFrame() ? window['requestAnimationFrame'](f) : setTimeout(f, 1); // React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\n\n\nconst useIsomorphicLayoutEffect = IS_SERVER ? useEffect : useLayoutEffect; // This assignment is to extend the Navigator type to use effectiveType.\n\nconst navigatorConnection = typeof navigator !== 'undefined' && navigator.connection; // Adjust the config based on slow connection status (<= 70Kbps).\n\nconst slowConnection = !IS_SERVER && navigatorConnection && (['slow-2g', '2g'].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData);\n\nconst serialize = key => {\n  if (isFunction(key)) {\n    try {\n      key = key();\n    } catch (err) {\n      // dependencies not ready\n      key = '';\n    }\n  } // Use the original key as the argument of fetcher. This can be a string or an\n  // array of values.\n\n\n  const args = key; // If key is not falsy, or not an empty array, hash it.\n\n  key = typeof key == 'string' ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : '';\n  return [key, args];\n}; // Global timestamp.\n\n\nlet __timestamp = 0;\n\nconst getTimestamp = () => ++__timestamp;\n\nconst FOCUS_EVENT = 0;\nconst RECONNECT_EVENT = 1;\nconst MUTATE_EVENT = 2;\nconst ERROR_REVALIDATE_EVENT = 3;\nvar events = {\n  __proto__: null,\n  ERROR_REVALIDATE_EVENT: ERROR_REVALIDATE_EVENT,\n  FOCUS_EVENT: FOCUS_EVENT,\n  MUTATE_EVENT: MUTATE_EVENT,\n  RECONNECT_EVENT: RECONNECT_EVENT\n};\n\nasync function internalMutate() {\n  for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  const [cache, _key, _data, _opts] = args; // When passing as a boolean, it's explicitly used to disable/enable\n  // revalidation.\n\n  const options = mergeObjects({\n    populateCache: true,\n    throwOnError: true\n  }, typeof _opts === 'boolean' ? {\n    revalidate: _opts\n  } : _opts || {});\n  let populateCache = options.populateCache;\n  const rollbackOnErrorOption = options.rollbackOnError;\n  let optimisticData = options.optimisticData;\n\n  const rollbackOnError = error => {\n    return typeof rollbackOnErrorOption === 'function' ? rollbackOnErrorOption(error) : rollbackOnErrorOption !== false;\n  };\n\n  const throwOnError = options.throwOnError; // If the second argument is a key filter, return the mutation results for all\n  // filtered keys.\n\n  if (isFunction(_key)) {\n    const keyFilter = _key;\n    const matchedKeys = [];\n    const it = cache.keys();\n\n    for (const key of it) {\n      if ( // Skip the special useSWRInfinite and useSWRSubscription keys.\n      !/^\\$(inf|sub)\\$/.test(key) && keyFilter(cache.get(key)._k)) {\n        matchedKeys.push(key);\n      }\n    }\n\n    return Promise.all(matchedKeys.map(mutateByKey));\n  }\n\n  return mutateByKey(_key);\n\n  async function mutateByKey(_k) {\n    // Serialize key\n    const [key] = serialize(_k);\n    if (!key) return;\n    const [get, set] = createCacheHelper(cache, key);\n    const [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = SWRGlobalState.get(cache);\n\n    const startRevalidate = () => {\n      const revalidators = EVENT_REVALIDATORS[key];\n      const revalidate = isFunction(options.revalidate) ? options.revalidate(get().data, _k) : options.revalidate !== false;\n\n      if (revalidate) {\n        // Invalidate the key by deleting the concurrent request markers so new\n        // requests will not be deduped.\n        delete FETCH[key];\n        delete PRELOAD[key];\n\n        if (revalidators && revalidators[0]) {\n          return revalidators[0](MUTATE_EVENT).then(() => get().data);\n        }\n      }\n\n      return get().data;\n    }; // If there is no new data provided, revalidate the key with current state.\n\n\n    if (args.length < 3) {\n      // Revalidate and broadcast state.\n      return startRevalidate();\n    }\n\n    let data = _data;\n    let error; // Update global timestamps.\n\n    const beforeMutationTs = getTimestamp();\n    MUTATION[key] = [beforeMutationTs, 0];\n    const hasOptimisticData = !isUndefined(optimisticData);\n    const state = get(); // `displayedData` is the current value on screen. It could be the optimistic value\n    // that is going to be overridden by a `committedData`, or get reverted back.\n    // `committedData` is the validated value that comes from a fetch or mutation.\n\n    const displayedData = state.data;\n    const currentData = state._c;\n    const committedData = isUndefined(currentData) ? displayedData : currentData; // Do optimistic data update.\n\n    if (hasOptimisticData) {\n      optimisticData = isFunction(optimisticData) ? optimisticData(committedData, displayedData) : optimisticData; // When we set optimistic data, backup the current committedData data in `_c`.\n\n      set({\n        data: optimisticData,\n        _c: committedData\n      });\n    }\n\n    if (isFunction(data)) {\n      // `data` is a function, call it passing current cache value.\n      try {\n        data = data(committedData);\n      } catch (err) {\n        // If it throws an error synchronously, we shouldn't update the cache.\n        error = err;\n      }\n    } // `data` is a promise/thenable, resolve the final data first.\n\n\n    if (data && isPromiseLike(data)) {\n      // This means that the mutation is async, we need to check timestamps to\n      // avoid race conditions.\n      data = await data.catch(err => {\n        error = err;\n      }); // Check if other mutations have occurred since we've started this mutation.\n      // If there's a race we don't update cache or broadcast the change,\n      // just return the data.\n\n      if (beforeMutationTs !== MUTATION[key][0]) {\n        if (error) throw error;\n        return data;\n      } else if (error && hasOptimisticData && rollbackOnError(error)) {\n        // Rollback. Always populate the cache in this case but without\n        // transforming the data.\n        populateCache = true; // Reset data to be the latest committed data, and clear the `_c` value.\n\n        set({\n          data: committedData,\n          _c: UNDEFINED\n        });\n      }\n    } // If we should write back the cache after request.\n\n\n    if (populateCache) {\n      if (!error) {\n        // Transform the result into data.\n        if (isFunction(populateCache)) {\n          const populateCachedData = populateCache(data, committedData);\n          set({\n            data: populateCachedData,\n            error: UNDEFINED,\n            _c: UNDEFINED\n          });\n        } else {\n          // Only update cached data and reset the error if there's no error. Data can be `undefined` here.\n          set({\n            data,\n            error: UNDEFINED,\n            _c: UNDEFINED\n          });\n        }\n      }\n    } // Reset the timestamp to mark the mutation has ended.\n\n\n    MUTATION[key][1] = getTimestamp(); // Update existing SWR Hooks' internal states:\n\n    Promise.resolve(startRevalidate()).then(() => {\n      // The mutation and revalidation are ended, we can clear it since the data is\n      // not an optimistic value anymore.\n      set({\n        _c: UNDEFINED\n      });\n    }); // Throw error or return data\n\n    if (error) {\n      if (throwOnError) throw error;\n      return;\n    }\n\n    return data;\n  }\n}\n\nconst revalidateAllKeys = (revalidators, type) => {\n  for (const key in revalidators) {\n    if (revalidators[key][0]) revalidators[key][0](type);\n  }\n};\n\nconst initCache = (provider, options) => {\n  // The global state for a specific provider will be used to deduplicate\n  // requests and store listeners. As well as a mutate function that is bound to\n  // the cache.\n  // The provider's global state might be already initialized. Let's try to get the\n  // global state associated with the provider first.\n  if (!SWRGlobalState.has(provider)) {\n    const opts = mergeObjects(defaultConfigOptions, options); // If there's no global state bound to the provider, create a new one with the\n    // new mutate function.\n\n    const EVENT_REVALIDATORS = {};\n    const mutate = internalMutate.bind(UNDEFINED, provider);\n    let unmount = noop;\n    const subscriptions = {};\n\n    const subscribe = (key, callback) => {\n      const subs = subscriptions[key] || [];\n      subscriptions[key] = subs;\n      subs.push(callback);\n      return () => subs.splice(subs.indexOf(callback), 1);\n    };\n\n    const setter = (key, value, prev) => {\n      provider.set(key, value);\n      const subs = subscriptions[key];\n\n      if (subs) {\n        for (const fn of subs) {\n          fn(value, prev);\n        }\n      }\n    };\n\n    const initProvider = () => {\n      if (!SWRGlobalState.has(provider)) {\n        // Update the state if it's new, or if the provider has been extended.\n        SWRGlobalState.set(provider, [EVENT_REVALIDATORS, {}, {}, {}, mutate, setter, subscribe]);\n\n        if (!IS_SERVER) {\n          // When listening to the native events for auto revalidations,\n          // we intentionally put a delay (setTimeout) here to make sure they are\n          // fired after immediate JavaScript executions, which can be\n          // React's state updates.\n          // This avoids some unnecessary revalidations such as\n          // https://github.com/vercel/swr/issues/1680.\n          const releaseFocus = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, FOCUS_EVENT)));\n          const releaseReconnect = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, RECONNECT_EVENT)));\n\n          unmount = () => {\n            releaseFocus && releaseFocus();\n            releaseReconnect && releaseReconnect(); // When un-mounting, we need to remove the cache provider from the state\n            // storage too because it's a side-effect. Otherwise, when re-mounting we\n            // will not re-register those event listeners.\n\n            SWRGlobalState.delete(provider);\n          };\n        }\n      }\n    };\n\n    initProvider(); // This is a new provider, we need to initialize it and setup DOM events\n    // listeners for `focus` and `reconnect` actions.\n    // We might want to inject an extra layer on top of `provider` in the future,\n    // such as key serialization, auto GC, etc.\n    // For now, it's just a `Map` interface without any modifications.\n\n    return [provider, mutate, initProvider, unmount];\n  }\n\n  return [provider, SWRGlobalState.get(provider)[4]];\n}; // error retry\n\n\nconst onErrorRetry = (_, __, config, revalidate, opts) => {\n  const maxRetryCount = config.errorRetryCount;\n  const currentRetryCount = opts.retryCount; // Exponential backoff\n\n  const timeout = ~~((Math.random() + 0.5) * (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config.errorRetryInterval;\n\n  if (!isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount) {\n    return;\n  }\n\n  setTimeout(revalidate, timeout, opts);\n};\n\nconst compare = (currentData, newData) => stableHash(currentData) == stableHash(newData); // Default cache provider\n\n\nconst [cache, mutate] = initCache(new Map()); // Default config\n\nconst defaultConfig = mergeObjects({\n  // events\n  onLoadingSlow: noop,\n  onSuccess: noop,\n  onError: noop,\n  onErrorRetry,\n  onDiscarded: noop,\n  // switches\n  revalidateOnFocus: true,\n  revalidateOnReconnect: true,\n  revalidateIfStale: true,\n  shouldRetryOnError: true,\n  // timeouts\n  errorRetryInterval: slowConnection ? 10000 : 5000,\n  focusThrottleInterval: 5 * 1000,\n  dedupingInterval: 2 * 1000,\n  loadingTimeout: slowConnection ? 5000 : 3000,\n  // providers\n  compare,\n  isPaused: () => false,\n  cache,\n  mutate,\n  fallback: {}\n}, // use web preset by default\npreset);\n\nconst mergeConfigs = (a, b) => {\n  // Need to create a new object to avoid mutating the original here.\n  const v = mergeObjects(a, b); // If two configs are provided, merge their `use` and `fallback` options.\n\n  if (b) {\n    const {\n      use: u1,\n      fallback: f1\n    } = a;\n    const {\n      use: u2,\n      fallback: f2\n    } = b;\n\n    if (u1 && u2) {\n      v.use = u1.concat(u2);\n    }\n\n    if (f1 && f2) {\n      v.fallback = mergeObjects(f1, f2);\n    }\n  }\n\n  return v;\n};\n\nconst SWRConfigContext = createContext({});\n\nconst SWRConfig = props => {\n  const {\n    value\n  } = props;\n  const parentConfig = useContext(SWRConfigContext);\n  const isFunctionalConfig = isFunction(value);\n  const config = useMemo(() => isFunctionalConfig ? value(parentConfig) : value, [isFunctionalConfig, parentConfig, value]); // Extend parent context values and middleware.\n\n  const extendedConfig = useMemo(() => isFunctionalConfig ? config : mergeConfigs(parentConfig, config), [isFunctionalConfig, parentConfig, config]); // Should not use the inherited provider.\n\n  const provider = config && config.provider; // initialize the cache only on first access.\n\n  const cacheContextRef = useRef(UNDEFINED);\n\n  if (provider && !cacheContextRef.current) {\n    cacheContextRef.current = initCache(provider(extendedConfig.cache || cache), config);\n  }\n\n  const cacheContext = cacheContextRef.current; // Override the cache if a new provider is given.\n\n  if (cacheContext) {\n    extendedConfig.cache = cacheContext[0];\n    extendedConfig.mutate = cacheContext[1];\n  } // Unsubscribe events.\n\n\n  useIsomorphicLayoutEffect(() => {\n    if (cacheContext) {\n      cacheContext[2] && cacheContext[2]();\n      return cacheContext[3];\n    }\n  }, []);\n  return createElement(SWRConfigContext.Provider, mergeObjects(props, {\n    value: extendedConfig\n  }));\n};\n\nconst INFINITE_PREFIX = '$inf$'; // @ts-expect-error\n\nconst enableDevtools = isWindowDefined && window.__SWR_DEVTOOLS_USE__;\nconst use = enableDevtools ? window.__SWR_DEVTOOLS_USE__ : [];\n\nconst setupDevTools = () => {\n  if (enableDevtools) {\n    // @ts-expect-error\n    window.__SWR_DEVTOOLS_REACT__ = React;\n  }\n};\n\nconst normalize = args => {\n  return isFunction(args[1]) ? [args[0], args[1], args[2] || {}] : [args[0], null, (args[1] === null ? args[2] : args[1]) || {}];\n};\n\nconst useSWRConfig = () => {\n  return mergeObjects(defaultConfig, useContext(SWRConfigContext));\n};\n\nconst preload = (key_, fetcher) => {\n  const [key, fnArg] = serialize(key_);\n  const [,,, PRELOAD] = SWRGlobalState.get(cache); // Prevent preload to be called multiple times before used.\n\n  if (PRELOAD[key]) return PRELOAD[key];\n  const req = fetcher(fnArg);\n  PRELOAD[key] = req;\n  return req;\n};\n\nconst middleware = useSWRNext => (key_, fetcher_, config) => {\n  // fetcher might be a sync function, so this should not be an async function\n  const fetcher = fetcher_ && function () {\n    const [key] = serialize(key_);\n    const [,,, PRELOAD] = SWRGlobalState.get(cache);\n\n    if (key.startsWith(INFINITE_PREFIX)) {\n      // we want the infinite fetcher to be called.\n      // handling of the PRELOAD cache happens there.\n      return fetcher_(...arguments);\n    }\n\n    const req = PRELOAD[key];\n    if (isUndefined(req)) return fetcher_(...arguments);\n    delete PRELOAD[key];\n    return req;\n  };\n\n  return useSWRNext(key_, fetcher, config);\n};\n\nconst BUILT_IN_MIDDLEWARE = use.concat(middleware); // It's tricky to pass generic types as parameters, so we just directly override\n// the types here.\n\nconst withArgs = hook => {\n  return function useSWRArgs() {\n    // Get the default and inherited configuration.\n    const fallbackConfig = useSWRConfig(); // Normalize arguments.\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    const [key, fn, _config] = normalize(args); // Merge configurations.\n\n    const config = mergeConfigs(fallbackConfig, _config); // Apply middleware\n\n    let next = hook;\n    const {\n      use\n    } = config;\n    const middleware = (use || []).concat(BUILT_IN_MIDDLEWARE);\n\n    for (let i = middleware.length; i--;) {\n      next = middleware[i](next);\n    }\n\n    return next(key, fn || config.fetcher || null, config);\n  };\n}; // Add a callback function to a list of keyed callback functions and return\n// the unsubscribe function.\n\n\nconst subscribeCallback = (key, callbacks, callback) => {\n  const keyedRevalidators = callbacks[key] || (callbacks[key] = []);\n  keyedRevalidators.push(callback);\n  return () => {\n    const index = keyedRevalidators.indexOf(callback);\n\n    if (index >= 0) {\n      // O(1): faster than splice\n      keyedRevalidators[index] = keyedRevalidators[keyedRevalidators.length - 1];\n      keyedRevalidators.pop();\n    }\n  };\n}; // Create a custom hook with a middleware\n\n\nconst withMiddleware = (useSWR, middleware) => {\n  return function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    const [key, fn, config] = normalize(args);\n    const uses = (config.use || []).concat(middleware);\n    return useSWR(key, fn, { ...config,\n      use: uses\n    });\n  };\n};\n\nsetupDevTools();\nexport { INFINITE_PREFIX, IS_REACT_LEGACY, IS_SERVER, OBJECT, SWRConfig, SWRGlobalState, UNDEFINED, cache, compare, createCacheHelper, defaultConfig, defaultConfigOptions, getTimestamp, hasRequestAnimationFrame, initCache, internalMutate, isDocumentDefined, isFunction, isPromiseLike, isUndefined, isWindowDefined, mergeConfigs, mergeObjects, mutate, noop, normalize, preload, preset, rAF, events as revalidateEvents, serialize, slowConnection, stableHash, subscribeCallback, useIsomorphicLayoutEffect, useSWRConfig, withArgs, withMiddleware };","map":{"version":3,"sources":["/Users/jaybhullar/Desktop/team-5-capstone-team-5/app/frontend/node_modules/swr/dist/_internal/index.mjs"],"names":["React","useEffect","useLayoutEffect","createContext","useContext","useMemo","useRef","createElement","noop","UNDEFINED","OBJECT","Object","isUndefined","v","isFunction","mergeObjects","a","b","isPromiseLike","x","then","table","WeakMap","counter","stableHash","arg","type","constructor","isDate","Date","result","index","RegExp","get","set","Array","length","keys","sort","pop","toJSON","toString","JSON","stringify","SWRGlobalState","EMPTY_CACHE","INITIAL_CACHE","STR_UNDEFINED","isWindowDefined","window","isDocumentDefined","document","hasRequestAnimationFrame","createCacheHelper","cache","key","state","info","prev","online","isOnline","onWindowEvent","offWindowEvent","addEventListener","bind","removeEventListener","isVisible","visibilityState","initFocus","callback","initReconnect","onOnline","onOffline","preset","defaultConfigOptions","IS_REACT_LEGACY","useId","IS_SERVER","rAF","f","setTimeout","useIsomorphicLayoutEffect","navigatorConnection","navigator","connection","slowConnection","includes","effectiveType","saveData","serialize","err","args","isArray","__timestamp","getTimestamp","FOCUS_EVENT","RECONNECT_EVENT","MUTATE_EVENT","ERROR_REVALIDATE_EVENT","events","__proto__","internalMutate","_key","_data","_opts","options","populateCache","throwOnError","revalidate","rollbackOnErrorOption","rollbackOnError","optimisticData","error","keyFilter","matchedKeys","it","test","_k","push","Promise","all","map","mutateByKey","EVENT_REVALIDATORS","MUTATION","FETCH","PRELOAD","startRevalidate","revalidators","data","beforeMutationTs","hasOptimisticData","displayedData","currentData","_c","committedData","catch","populateCachedData","resolve","revalidateAllKeys","initCache","provider","has","opts","mutate","unmount","subscriptions","subscribe","subs","splice","indexOf","setter","value","fn","initProvider","releaseFocus","releaseReconnect","delete","onErrorRetry","_","__","config","maxRetryCount","errorRetryCount","currentRetryCount","retryCount","timeout","Math","random","errorRetryInterval","compare","newData","Map","defaultConfig","onLoadingSlow","onSuccess","onError","onDiscarded","revalidateOnFocus","revalidateOnReconnect","revalidateIfStale","shouldRetryOnError","focusThrottleInterval","dedupingInterval","loadingTimeout","isPaused","fallback","mergeConfigs","use","u1","f1","u2","f2","concat","SWRConfigContext","SWRConfig","props","parentConfig","isFunctionalConfig","extendedConfig","cacheContextRef","current","cacheContext","Provider","INFINITE_PREFIX","enableDevtools","__SWR_DEVTOOLS_USE__","setupDevTools","__SWR_DEVTOOLS_REACT__","normalize","useSWRConfig","preload","key_","fetcher","fnArg","req","middleware","useSWRNext","fetcher_","startsWith","BUILT_IN_MIDDLEWARE","withArgs","hook","useSWRArgs","fallbackConfig","_config","next","i","subscribeCallback","callbacks","keyedRevalidators","withMiddleware","useSWR","uses","revalidateEvents"],"mappings":"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","sourcesContent":["import React, { useEffect, useLayoutEffect, createContext, useContext, useMemo, useRef, createElement } from 'react';\n\n// Shared state between server components and client components\nconst noop = ()=>{};\n// Using noop() as the undefined value as undefined can be replaced\n// by something else. Prettier ignore and extra parentheses are necessary here\n// to ensure that tsc doesn't remove the __NOINLINE__ comment.\n// prettier-ignore\nconst UNDEFINED = /*#__NOINLINE__*/ noop();\nconst OBJECT = Object;\nconst isUndefined = (v)=>v === UNDEFINED;\nconst isFunction = (v)=>typeof v == 'function';\nconst mergeObjects = (a, b)=>({\n        ...a,\n        ...b\n    });\nconst isPromiseLike = (x)=>isFunction(x.then);\n\n// use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\nconst table = new WeakMap();\n// counter of the key\nlet counter = 0;\n// A stable hash implementation that supports:\n// - Fast and ensures unique hash properties\n// - Handles unserializable values\n// - Handles object key ordering\n// - Generates short results\n//\n// This is not a serialization function, and the result is not guaranteed to be\n// parsable.\nconst stableHash = (arg)=>{\n    const type = typeof arg;\n    const constructor = arg && arg.constructor;\n    const isDate = constructor == Date;\n    let result;\n    let index;\n    if (OBJECT(arg) === arg && !isDate && constructor != RegExp) {\n        // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n        // If it's already hashed, directly return the result.\n        result = table.get(arg);\n        if (result) return result;\n        // Store the hash first for circular reference detection before entering the\n        // recursive `stableHash` calls.\n        // For other objects like set and map, we use this id directly as the hash.\n        result = ++counter + '~';\n        table.set(arg, result);\n        if (constructor == Array) {\n            // Array.\n            result = '@';\n            for(index = 0; index < arg.length; index++){\n                result += stableHash(arg[index]) + ',';\n            }\n            table.set(arg, result);\n        }\n        if (constructor == OBJECT) {\n            // Object, sort keys.\n            result = '#';\n            const keys = OBJECT.keys(arg).sort();\n            while(!isUndefined(index = keys.pop())){\n                if (!isUndefined(arg[index])) {\n                    result += index + ':' + stableHash(arg[index]) + ',';\n                }\n            }\n            table.set(arg, result);\n        }\n    } else {\n        result = isDate ? arg.toJSON() : type == 'symbol' ? arg.toString() : type == 'string' ? JSON.stringify(arg) : '' + arg;\n    }\n    return result;\n};\n\n// Global state used to deduplicate requests and store listeners\nconst SWRGlobalState = new WeakMap();\n\nconst EMPTY_CACHE = {};\nconst INITIAL_CACHE = {};\nconst STR_UNDEFINED = 'undefined';\n// NOTE: Use the function to guarantee it's re-evaluated between jsdom and node runtime for tests.\nconst isWindowDefined = typeof window != STR_UNDEFINED;\nconst isDocumentDefined = typeof document != STR_UNDEFINED;\nconst hasRequestAnimationFrame = ()=>isWindowDefined && typeof window['requestAnimationFrame'] != STR_UNDEFINED;\nconst createCacheHelper = (cache, key)=>{\n    const state = SWRGlobalState.get(cache);\n    return [\n        // Getter\n        ()=>!isUndefined(key) && cache.get(key) || EMPTY_CACHE,\n        // Setter\n        (info)=>{\n            if (!isUndefined(key)) {\n                const prev = cache.get(key);\n                // Before writing to the store, we keep the value in the initial cache\n                // if it's not there yet.\n                if (!(key in INITIAL_CACHE)) {\n                    INITIAL_CACHE[key] = prev;\n                }\n                state[5](key, mergeObjects(prev, info), prev || EMPTY_CACHE);\n            }\n        },\n        // Subscriber\n        state[6],\n        // Get server cache snapshot\n        ()=>{\n            if (!isUndefined(key)) {\n                // If the cache was updated on the client, we return the stored initial value.\n                if (key in INITIAL_CACHE) return INITIAL_CACHE[key];\n            }\n            // If we haven't done any client-side updates, we return the current value.\n            return !isUndefined(key) && cache.get(key) || EMPTY_CACHE;\n        }\n    ];\n} // export { UNDEFINED, OBJECT, isUndefined, isFunction, mergeObjects, isPromiseLike }\n;\n\n/**\n * Due to the bug https://bugs.chromium.org/p/chromium/issues/detail?id=678075,\n * it's not reliable to detect if the browser is currently online or offline\n * based on `navigator.onLine`.\n * As a workaround, we always assume it's online on the first load, and change\n * the status upon `online` or `offline` events.\n */ let online = true;\nconst isOnline = ()=>online;\n// For node and React Native, `add/removeEventListener` doesn't exist on window.\nconst [onWindowEvent, offWindowEvent] = isWindowDefined && window.addEventListener ? [\n    window.addEventListener.bind(window),\n    window.removeEventListener.bind(window)\n] : [\n    noop,\n    noop\n];\nconst isVisible = ()=>{\n    const visibilityState = isDocumentDefined && document.visibilityState;\n    return isUndefined(visibilityState) || visibilityState !== 'hidden';\n};\nconst initFocus = (callback)=>{\n    // focus revalidate\n    if (isDocumentDefined) {\n        document.addEventListener('visibilitychange', callback);\n    }\n    onWindowEvent('focus', callback);\n    return ()=>{\n        if (isDocumentDefined) {\n            document.removeEventListener('visibilitychange', callback);\n        }\n        offWindowEvent('focus', callback);\n    };\n};\nconst initReconnect = (callback)=>{\n    // revalidate on reconnected\n    const onOnline = ()=>{\n        online = true;\n        callback();\n    };\n    // nothing to revalidate, just update the status\n    const onOffline = ()=>{\n        online = false;\n    };\n    onWindowEvent('online', onOnline);\n    onWindowEvent('offline', onOffline);\n    return ()=>{\n        offWindowEvent('online', onOnline);\n        offWindowEvent('offline', onOffline);\n    };\n};\nconst preset = {\n    isOnline,\n    isVisible\n};\nconst defaultConfigOptions = {\n    initFocus,\n    initReconnect\n};\n\nconst IS_REACT_LEGACY = !React.useId;\nconst IS_SERVER = !isWindowDefined || 'Deno' in window;\n// Polyfill requestAnimationFrame\nconst rAF = (f)=>hasRequestAnimationFrame() ? window['requestAnimationFrame'](f) : setTimeout(f, 1);\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\nconst useIsomorphicLayoutEffect = IS_SERVER ? useEffect : useLayoutEffect;\n// This assignment is to extend the Navigator type to use effectiveType.\nconst navigatorConnection = typeof navigator !== 'undefined' && navigator.connection;\n// Adjust the config based on slow connection status (<= 70Kbps).\nconst slowConnection = !IS_SERVER && navigatorConnection && ([\n    'slow-2g',\n    '2g'\n].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData);\n\nconst serialize = (key)=>{\n    if (isFunction(key)) {\n        try {\n            key = key();\n        } catch (err) {\n            // dependencies not ready\n            key = '';\n        }\n    }\n    // Use the original key as the argument of fetcher. This can be a string or an\n    // array of values.\n    const args = key;\n    // If key is not falsy, or not an empty array, hash it.\n    key = typeof key == 'string' ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : '';\n    return [\n        key,\n        args\n    ];\n};\n\n// Global timestamp.\nlet __timestamp = 0;\nconst getTimestamp = ()=>++__timestamp;\n\nconst FOCUS_EVENT = 0;\nconst RECONNECT_EVENT = 1;\nconst MUTATE_EVENT = 2;\nconst ERROR_REVALIDATE_EVENT = 3;\n\nvar events = {\n  __proto__: null,\n  ERROR_REVALIDATE_EVENT: ERROR_REVALIDATE_EVENT,\n  FOCUS_EVENT: FOCUS_EVENT,\n  MUTATE_EVENT: MUTATE_EVENT,\n  RECONNECT_EVENT: RECONNECT_EVENT\n};\n\nasync function internalMutate(...args) {\n    const [cache, _key, _data, _opts] = args;\n    // When passing as a boolean, it's explicitly used to disable/enable\n    // revalidation.\n    const options = mergeObjects({\n        populateCache: true,\n        throwOnError: true\n    }, typeof _opts === 'boolean' ? {\n        revalidate: _opts\n    } : _opts || {});\n    let populateCache = options.populateCache;\n    const rollbackOnErrorOption = options.rollbackOnError;\n    let optimisticData = options.optimisticData;\n    const rollbackOnError = (error)=>{\n        return typeof rollbackOnErrorOption === 'function' ? rollbackOnErrorOption(error) : rollbackOnErrorOption !== false;\n    };\n    const throwOnError = options.throwOnError;\n    // If the second argument is a key filter, return the mutation results for all\n    // filtered keys.\n    if (isFunction(_key)) {\n        const keyFilter = _key;\n        const matchedKeys = [];\n        const it = cache.keys();\n        for (const key of it){\n            if (// Skip the special useSWRInfinite and useSWRSubscription keys.\n            !/^\\$(inf|sub)\\$/.test(key) && keyFilter(cache.get(key)._k)) {\n                matchedKeys.push(key);\n            }\n        }\n        return Promise.all(matchedKeys.map(mutateByKey));\n    }\n    return mutateByKey(_key);\n    async function mutateByKey(_k) {\n        // Serialize key\n        const [key] = serialize(_k);\n        if (!key) return;\n        const [get, set] = createCacheHelper(cache, key);\n        const [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = SWRGlobalState.get(cache);\n        const startRevalidate = ()=>{\n            const revalidators = EVENT_REVALIDATORS[key];\n            const revalidate = isFunction(options.revalidate) ? options.revalidate(get().data, _k) : options.revalidate !== false;\n            if (revalidate) {\n                // Invalidate the key by deleting the concurrent request markers so new\n                // requests will not be deduped.\n                delete FETCH[key];\n                delete PRELOAD[key];\n                if (revalidators && revalidators[0]) {\n                    return revalidators[0](MUTATE_EVENT).then(()=>get().data);\n                }\n            }\n            return get().data;\n        };\n        // If there is no new data provided, revalidate the key with current state.\n        if (args.length < 3) {\n            // Revalidate and broadcast state.\n            return startRevalidate();\n        }\n        let data = _data;\n        let error;\n        // Update global timestamps.\n        const beforeMutationTs = getTimestamp();\n        MUTATION[key] = [\n            beforeMutationTs,\n            0\n        ];\n        const hasOptimisticData = !isUndefined(optimisticData);\n        const state = get();\n        // `displayedData` is the current value on screen. It could be the optimistic value\n        // that is going to be overridden by a `committedData`, or get reverted back.\n        // `committedData` is the validated value that comes from a fetch or mutation.\n        const displayedData = state.data;\n        const currentData = state._c;\n        const committedData = isUndefined(currentData) ? displayedData : currentData;\n        // Do optimistic data update.\n        if (hasOptimisticData) {\n            optimisticData = isFunction(optimisticData) ? optimisticData(committedData, displayedData) : optimisticData;\n            // When we set optimistic data, backup the current committedData data in `_c`.\n            set({\n                data: optimisticData,\n                _c: committedData\n            });\n        }\n        if (isFunction(data)) {\n            // `data` is a function, call it passing current cache value.\n            try {\n                data = data(committedData);\n            } catch (err) {\n                // If it throws an error synchronously, we shouldn't update the cache.\n                error = err;\n            }\n        }\n        // `data` is a promise/thenable, resolve the final data first.\n        if (data && isPromiseLike(data)) {\n            // This means that the mutation is async, we need to check timestamps to\n            // avoid race conditions.\n            data = await data.catch((err)=>{\n                error = err;\n            });\n            // Check if other mutations have occurred since we've started this mutation.\n            // If there's a race we don't update cache or broadcast the change,\n            // just return the data.\n            if (beforeMutationTs !== MUTATION[key][0]) {\n                if (error) throw error;\n                return data;\n            } else if (error && hasOptimisticData && rollbackOnError(error)) {\n                // Rollback. Always populate the cache in this case but without\n                // transforming the data.\n                populateCache = true;\n                // Reset data to be the latest committed data, and clear the `_c` value.\n                set({\n                    data: committedData,\n                    _c: UNDEFINED\n                });\n            }\n        }\n        // If we should write back the cache after request.\n        if (populateCache) {\n            if (!error) {\n                // Transform the result into data.\n                if (isFunction(populateCache)) {\n                    const populateCachedData = populateCache(data, committedData);\n                    set({\n                        data: populateCachedData,\n                        error: UNDEFINED,\n                        _c: UNDEFINED\n                    });\n                } else {\n                    // Only update cached data and reset the error if there's no error. Data can be `undefined` here.\n                    set({\n                        data,\n                        error: UNDEFINED,\n                        _c: UNDEFINED\n                    });\n                }\n            }\n        }\n        // Reset the timestamp to mark the mutation has ended.\n        MUTATION[key][1] = getTimestamp();\n        // Update existing SWR Hooks' internal states:\n        Promise.resolve(startRevalidate()).then(()=>{\n            // The mutation and revalidation are ended, we can clear it since the data is\n            // not an optimistic value anymore.\n            set({\n                _c: UNDEFINED\n            });\n        });\n        // Throw error or return data\n        if (error) {\n            if (throwOnError) throw error;\n            return;\n        }\n        return data;\n    }\n}\n\nconst revalidateAllKeys = (revalidators, type)=>{\n    for(const key in revalidators){\n        if (revalidators[key][0]) revalidators[key][0](type);\n    }\n};\nconst initCache = (provider, options)=>{\n    // The global state for a specific provider will be used to deduplicate\n    // requests and store listeners. As well as a mutate function that is bound to\n    // the cache.\n    // The provider's global state might be already initialized. Let's try to get the\n    // global state associated with the provider first.\n    if (!SWRGlobalState.has(provider)) {\n        const opts = mergeObjects(defaultConfigOptions, options);\n        // If there's no global state bound to the provider, create a new one with the\n        // new mutate function.\n        const EVENT_REVALIDATORS = {};\n        const mutate = internalMutate.bind(UNDEFINED, provider);\n        let unmount = noop;\n        const subscriptions = {};\n        const subscribe = (key, callback)=>{\n            const subs = subscriptions[key] || [];\n            subscriptions[key] = subs;\n            subs.push(callback);\n            return ()=>subs.splice(subs.indexOf(callback), 1);\n        };\n        const setter = (key, value, prev)=>{\n            provider.set(key, value);\n            const subs = subscriptions[key];\n            if (subs) {\n                for (const fn of subs){\n                    fn(value, prev);\n                }\n            }\n        };\n        const initProvider = ()=>{\n            if (!SWRGlobalState.has(provider)) {\n                // Update the state if it's new, or if the provider has been extended.\n                SWRGlobalState.set(provider, [\n                    EVENT_REVALIDATORS,\n                    {},\n                    {},\n                    {},\n                    mutate,\n                    setter,\n                    subscribe\n                ]);\n                if (!IS_SERVER) {\n                    // When listening to the native events for auto revalidations,\n                    // we intentionally put a delay (setTimeout) here to make sure they are\n                    // fired after immediate JavaScript executions, which can be\n                    // React's state updates.\n                    // This avoids some unnecessary revalidations such as\n                    // https://github.com/vercel/swr/issues/1680.\n                    const releaseFocus = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, FOCUS_EVENT)));\n                    const releaseReconnect = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, RECONNECT_EVENT)));\n                    unmount = ()=>{\n                        releaseFocus && releaseFocus();\n                        releaseReconnect && releaseReconnect();\n                        // When un-mounting, we need to remove the cache provider from the state\n                        // storage too because it's a side-effect. Otherwise, when re-mounting we\n                        // will not re-register those event listeners.\n                        SWRGlobalState.delete(provider);\n                    };\n                }\n            }\n        };\n        initProvider();\n        // This is a new provider, we need to initialize it and setup DOM events\n        // listeners for `focus` and `reconnect` actions.\n        // We might want to inject an extra layer on top of `provider` in the future,\n        // such as key serialization, auto GC, etc.\n        // For now, it's just a `Map` interface without any modifications.\n        return [\n            provider,\n            mutate,\n            initProvider,\n            unmount\n        ];\n    }\n    return [\n        provider,\n        SWRGlobalState.get(provider)[4]\n    ];\n};\n\n// error retry\nconst onErrorRetry = (_, __, config, revalidate, opts)=>{\n    const maxRetryCount = config.errorRetryCount;\n    const currentRetryCount = opts.retryCount;\n    // Exponential backoff\n    const timeout = ~~((Math.random() + 0.5) * (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config.errorRetryInterval;\n    if (!isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount) {\n        return;\n    }\n    setTimeout(revalidate, timeout, opts);\n};\nconst compare = (currentData, newData)=>stableHash(currentData) == stableHash(newData);\n// Default cache provider\nconst [cache, mutate] = initCache(new Map());\n// Default config\nconst defaultConfig = mergeObjects({\n    // events\n    onLoadingSlow: noop,\n    onSuccess: noop,\n    onError: noop,\n    onErrorRetry,\n    onDiscarded: noop,\n    // switches\n    revalidateOnFocus: true,\n    revalidateOnReconnect: true,\n    revalidateIfStale: true,\n    shouldRetryOnError: true,\n    // timeouts\n    errorRetryInterval: slowConnection ? 10000 : 5000,\n    focusThrottleInterval: 5 * 1000,\n    dedupingInterval: 2 * 1000,\n    loadingTimeout: slowConnection ? 5000 : 3000,\n    // providers\n    compare,\n    isPaused: ()=>false,\n    cache,\n    mutate,\n    fallback: {}\n}, // use web preset by default\npreset);\n\nconst mergeConfigs = (a, b)=>{\n    // Need to create a new object to avoid mutating the original here.\n    const v = mergeObjects(a, b);\n    // If two configs are provided, merge their `use` and `fallback` options.\n    if (b) {\n        const { use: u1, fallback: f1 } = a;\n        const { use: u2, fallback: f2 } = b;\n        if (u1 && u2) {\n            v.use = u1.concat(u2);\n        }\n        if (f1 && f2) {\n            v.fallback = mergeObjects(f1, f2);\n        }\n    }\n    return v;\n};\n\nconst SWRConfigContext = createContext({});\nconst SWRConfig = (props)=>{\n    const { value } = props;\n    const parentConfig = useContext(SWRConfigContext);\n    const isFunctionalConfig = isFunction(value);\n    const config = useMemo(()=>isFunctionalConfig ? value(parentConfig) : value, [\n        isFunctionalConfig,\n        parentConfig,\n        value\n    ]);\n    // Extend parent context values and middleware.\n    const extendedConfig = useMemo(()=>isFunctionalConfig ? config : mergeConfigs(parentConfig, config), [\n        isFunctionalConfig,\n        parentConfig,\n        config\n    ]);\n    // Should not use the inherited provider.\n    const provider = config && config.provider;\n    // initialize the cache only on first access.\n    const cacheContextRef = useRef(UNDEFINED);\n    if (provider && !cacheContextRef.current) {\n        cacheContextRef.current = initCache(provider(extendedConfig.cache || cache), config);\n    }\n    const cacheContext = cacheContextRef.current;\n    // Override the cache if a new provider is given.\n    if (cacheContext) {\n        extendedConfig.cache = cacheContext[0];\n        extendedConfig.mutate = cacheContext[1];\n    }\n    // Unsubscribe events.\n    useIsomorphicLayoutEffect(()=>{\n        if (cacheContext) {\n            cacheContext[2] && cacheContext[2]();\n            return cacheContext[3];\n        }\n    }, []);\n    return createElement(SWRConfigContext.Provider, mergeObjects(props, {\n        value: extendedConfig\n    }));\n};\n\nconst INFINITE_PREFIX = '$inf$';\n\n// @ts-expect-error\nconst enableDevtools = isWindowDefined && window.__SWR_DEVTOOLS_USE__;\nconst use = enableDevtools ? window.__SWR_DEVTOOLS_USE__ : [];\nconst setupDevTools = ()=>{\n    if (enableDevtools) {\n        // @ts-expect-error\n        window.__SWR_DEVTOOLS_REACT__ = React;\n    }\n};\n\nconst normalize = (args)=>{\n    return isFunction(args[1]) ? [\n        args[0],\n        args[1],\n        args[2] || {}\n    ] : [\n        args[0],\n        null,\n        (args[1] === null ? args[2] : args[1]) || {}\n    ];\n};\n\nconst useSWRConfig = ()=>{\n    return mergeObjects(defaultConfig, useContext(SWRConfigContext));\n};\n\nconst preload = (key_, fetcher)=>{\n    const [key, fnArg] = serialize(key_);\n    const [, , , PRELOAD] = SWRGlobalState.get(cache);\n    // Prevent preload to be called multiple times before used.\n    if (PRELOAD[key]) return PRELOAD[key];\n    const req = fetcher(fnArg);\n    PRELOAD[key] = req;\n    return req;\n};\nconst middleware = (useSWRNext)=>(key_, fetcher_, config)=>{\n        // fetcher might be a sync function, so this should not be an async function\n        const fetcher = fetcher_ && ((...args)=>{\n            const [key] = serialize(key_);\n            const [, , , PRELOAD] = SWRGlobalState.get(cache);\n            if (key.startsWith(INFINITE_PREFIX)) {\n                // we want the infinite fetcher to be called.\n                // handling of the PRELOAD cache happens there.\n                return fetcher_(...args);\n            }\n            const req = PRELOAD[key];\n            if (isUndefined(req)) return fetcher_(...args);\n            delete PRELOAD[key];\n            return req;\n        });\n        return useSWRNext(key_, fetcher, config);\n    };\n\nconst BUILT_IN_MIDDLEWARE = use.concat(middleware);\n\n// It's tricky to pass generic types as parameters, so we just directly override\n// the types here.\nconst withArgs = (hook)=>{\n    return function useSWRArgs(...args) {\n        // Get the default and inherited configuration.\n        const fallbackConfig = useSWRConfig();\n        // Normalize arguments.\n        const [key, fn, _config] = normalize(args);\n        // Merge configurations.\n        const config = mergeConfigs(fallbackConfig, _config);\n        // Apply middleware\n        let next = hook;\n        const { use } = config;\n        const middleware = (use || []).concat(BUILT_IN_MIDDLEWARE);\n        for(let i = middleware.length; i--;){\n            next = middleware[i](next);\n        }\n        return next(key, fn || config.fetcher || null, config);\n    };\n};\n\n// Add a callback function to a list of keyed callback functions and return\n// the unsubscribe function.\nconst subscribeCallback = (key, callbacks, callback)=>{\n    const keyedRevalidators = callbacks[key] || (callbacks[key] = []);\n    keyedRevalidators.push(callback);\n    return ()=>{\n        const index = keyedRevalidators.indexOf(callback);\n        if (index >= 0) {\n            // O(1): faster than splice\n            keyedRevalidators[index] = keyedRevalidators[keyedRevalidators.length - 1];\n            keyedRevalidators.pop();\n        }\n    };\n};\n\n// Create a custom hook with a middleware\nconst withMiddleware = (useSWR, middleware)=>{\n    return (...args)=>{\n        const [key, fn, config] = normalize(args);\n        const uses = (config.use || []).concat(middleware);\n        return useSWR(key, fn, {\n            ...config,\n            use: uses\n        });\n    };\n};\n\nsetupDevTools();\n\nexport { INFINITE_PREFIX, IS_REACT_LEGACY, IS_SERVER, OBJECT, SWRConfig, SWRGlobalState, UNDEFINED, cache, compare, createCacheHelper, defaultConfig, defaultConfigOptions, getTimestamp, hasRequestAnimationFrame, initCache, internalMutate, isDocumentDefined, isFunction, isPromiseLike, isUndefined, isWindowDefined, mergeConfigs, mergeObjects, mutate, noop, normalize, preload, preset, rAF, events as revalidateEvents, serialize, slowConnection, stableHash, subscribeCallback, useIsomorphicLayoutEffect, useSWRConfig, withArgs, withMiddleware };\n"]},"metadata":{},"sourceType":"module"}