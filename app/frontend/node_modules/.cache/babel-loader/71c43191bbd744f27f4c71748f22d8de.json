{"ast":null,"code":"// src/color.ts\nvar IS_HEX_COLOR_REGEX = /^#?([A-F0-9]{6}|[A-F0-9]{3})$/i;\nvar IS_RGB_COLOR_REGEX = /^rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)$/i;\nvar IS_RGBA_COLOR_REGEX = /^rgba\\((\\d+),\\s*(\\d+),\\s*(\\d+)(,\\s*\\d+(\\.\\d+)?)\\)$/i;\nvar IS_HSL_COLOR_REGEX = /^hsl\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%\\)$/i;\nvar IS_HSLA_COLOR_REGEX = /^hsla\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%(,\\s*\\d+(\\.\\d+)?)*\\)$/i;\n\nvar isValidHexString = s => {\n  return !!s.match(IS_HEX_COLOR_REGEX);\n};\n\nvar isValidRgbaString = s => {\n  return !!(s.match(IS_RGB_COLOR_REGEX) || s.match(IS_RGBA_COLOR_REGEX));\n};\n\nvar isValidHslaString = s => {\n  return !!s.match(IS_HSL_COLOR_REGEX) || !!s.match(IS_HSLA_COLOR_REGEX);\n};\n\nvar isRGBColor = c => {\n  return typeof c !== \"string\" && \"r\" in c;\n};\n\nvar isHSLColor = c => {\n  return typeof c !== \"string\" && \"h\" in c;\n};\n\nvar isTransparent = c => {\n  return c === \"transparent\";\n};\n\nvar hasAlpha = color => {\n  return typeof color !== \"string\" && color.a != void 0 && color.a < 1;\n};\n\nvar CLEAN_HSLA_REGEX = /[hsla()]/g;\nvar CLEAN_RGBA_REGEX = /[rgba()]/g;\n\nvar stringToHslaColor = value => {\n  if (value === \"transparent\") {\n    return {\n      h: 0,\n      s: 0,\n      l: 0,\n      a: 0\n    };\n  }\n\n  if (isValidHexString(value)) {\n    return hexStringToHslaColor(value);\n  }\n\n  if (isValidHslaString(value)) {\n    return parseHslaString(value);\n  }\n\n  if (isValidRgbaString(value)) {\n    return rgbaStringToHslaColor(value);\n  }\n\n  return null;\n};\n\nvar stringToSameTypeColor = value => {\n  value = value.trim();\n\n  if (isValidHexString(value)) {\n    return value.startsWith(\"#\") ? value : `#${value}`;\n  }\n\n  if (isValidRgbaString(value)) {\n    return parseRgbaString(value);\n  }\n\n  if (isValidHslaString(value)) {\n    return parseHslaString(value);\n  }\n\n  if (isTransparent(value)) {\n    return value;\n  }\n\n  return \"\";\n};\n\nvar colorToSameTypeString = color => {\n  if (typeof color === \"string\" && (isValidHexString(color) || isTransparent(color))) {\n    return color;\n  }\n\n  if (isRGBColor(color)) {\n    return rgbaColorToRgbaString(color);\n  }\n\n  if (isHSLColor(color)) {\n    return hslaColorToHslaString(color);\n  }\n\n  return \"\";\n};\n\nvar hexStringToRgbaColor = hex => {\n  hex = hex.replace(\"#\", \"\");\n  const r = parseInt(hex.substring(0, 2), 16);\n  const g = parseInt(hex.substring(2, 4), 16);\n  const b = parseInt(hex.substring(4, 6), 16);\n  return {\n    r,\n    g,\n    b\n  };\n};\n\nvar rgbaColorToRgbaString = color => {\n  const {\n    a,\n    b,\n    g,\n    r\n  } = color;\n  return color.a === 0 ? \"transparent\" : color.a != void 0 ? `rgba(${r},${g},${b},${a})` : `rgb(${r},${g},${b})`;\n};\n\nvar hslaColorToHslaString = color => {\n  const {\n    h,\n    s,\n    l,\n    a\n  } = color;\n  const sPerc = Math.round(s * 100);\n  const lPerc = Math.round(l * 100);\n  return color.a === 0 ? \"transparent\" : color.a != void 0 ? `hsla(${h},${sPerc}%,${lPerc}%,${a})` : `hsl(${h},${sPerc}%,${lPerc}%)`;\n};\n\nvar hexStringToHslaColor = hex => {\n  const rgbaString = colorToSameTypeString(hexStringToRgbaColor(hex));\n  return rgbaStringToHslaColor(rgbaString);\n};\n\nvar rgbaStringToHslaColor = rgba => {\n  const rgbaColor = parseRgbaString(rgba);\n  const r = rgbaColor.r / 255;\n  const g = rgbaColor.g / 255;\n  const b = rgbaColor.b / 255;\n  const max = Math.max(r, g, b),\n        min = Math.min(r, g, b);\n  let h, s;\n  const l = (max + min) / 2;\n\n  if (max == min) {\n    h = s = 0;\n  } else {\n    const d = max - min;\n    s = l >= 0.5 ? d / (2 - (max + min)) : d / (max + min);\n\n    switch (max) {\n      case r:\n        h = (g - b) / d * 60;\n        break;\n\n      case g:\n        h = ((b - r) / d + 2) * 60;\n        break;\n\n      default:\n        h = ((r - g) / d + 4) * 60;\n        break;\n    }\n  }\n\n  const res = {\n    h: Math.round(h),\n    s,\n    l\n  };\n  const a = rgbaColor.a;\n\n  if (a != void 0) {\n    res.a = a;\n  }\n\n  return res;\n};\n\nvar parseRgbaString = str => {\n  const [r, g, b, a] = str.replace(CLEAN_RGBA_REGEX, \"\").split(\",\").map(c => Number.parseFloat(c));\n  return {\n    r,\n    g,\n    b,\n    a\n  };\n};\n\nvar parseHslaString = str => {\n  const [h, s, l, a] = str.replace(CLEAN_HSLA_REGEX, \"\").split(\",\").map(c => Number.parseFloat(c));\n  return {\n    h,\n    s: s / 100,\n    l: l / 100,\n    a\n  };\n};\n\nexport { isValidHexString, isValidRgbaString, isValidHslaString, isRGBColor, isHSLColor, isTransparent, hasAlpha, stringToHslaColor, stringToSameTypeColor, colorToSameTypeString, hexStringToRgbaColor };","map":{"version":3,"mappings":"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","names":["IS_HEX_COLOR_REGEX","IS_RGB_COLOR_REGEX","IS_RGBA_COLOR_REGEX","IS_HSL_COLOR_REGEX","IS_HSLA_COLOR_REGEX","isValidHexString","s","match","isValidRgbaString","isValidHslaString","isRGBColor","c","isHSLColor","isTransparent","hasAlpha","color","a","CLEAN_HSLA_REGEX","CLEAN_RGBA_REGEX","stringToHslaColor","value","h","l","hexStringToHslaColor","parseHslaString","rgbaStringToHslaColor","stringToSameTypeColor","trim","startsWith","parseRgbaString","colorToSameTypeString","rgbaColorToRgbaString","hslaColorToHslaString","hexStringToRgbaColor","hex","replace","r","parseInt","substring","g","b","sPerc","Math","round","lPerc","rgbaString","rgba","rgbaColor","max","min","d","res","str","split","map","Number","parseFloat"],"sources":["/Users/jaybhullar/Desktop/team-5-capstone-team-5/app/frontend/node_modules/@clerk/shared/src/color.ts"],"sourcesContent":["import type { Color, HslaColor, RgbaColor, TransparentColor } from '@clerk/types';\n\nconst IS_HEX_COLOR_REGEX = /^#?([A-F0-9]{6}|[A-F0-9]{3})$/i;\n\nconst IS_RGB_COLOR_REGEX = /^rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)$/i;\nconst IS_RGBA_COLOR_REGEX = /^rgba\\((\\d+),\\s*(\\d+),\\s*(\\d+)(,\\s*\\d+(\\.\\d+)?)\\)$/i;\n\nconst IS_HSL_COLOR_REGEX = /^hsl\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%\\)$/i;\nconst IS_HSLA_COLOR_REGEX = /^hsla\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%(,\\s*\\d+(\\.\\d+)?)*\\)$/i;\n\nexport const isValidHexString = (s: string) => {\n  return !!s.match(IS_HEX_COLOR_REGEX);\n};\n\nexport const isValidRgbaString = (s: string) => {\n  return !!(s.match(IS_RGB_COLOR_REGEX) || s.match(IS_RGBA_COLOR_REGEX));\n};\n\nexport const isValidHslaString = (s: string) => {\n  return !!s.match(IS_HSL_COLOR_REGEX) || !!s.match(IS_HSLA_COLOR_REGEX);\n};\n\nexport const isRGBColor = (c: Color): c is RgbaColor => {\n  return typeof c !== 'string' && 'r' in c;\n};\n\nexport const isHSLColor = (c: Color): c is HslaColor => {\n  return typeof c !== 'string' && 'h' in c;\n};\n\nexport const isTransparent = (c: Color): c is TransparentColor => {\n  return c === 'transparent';\n};\n\nexport const hasAlpha = (color: Color): boolean => {\n  return typeof color !== 'string' && color.a != undefined && color.a < 1;\n};\n\nconst CLEAN_HSLA_REGEX = /[hsla()]/g;\nconst CLEAN_RGBA_REGEX = /[rgba()]/g;\n\nexport const stringToHslaColor = (value: string): HslaColor | null => {\n  if (value === 'transparent') {\n    return { h: 0, s: 0, l: 0, a: 0 };\n  }\n\n  if (isValidHexString(value)) {\n    return hexStringToHslaColor(value);\n  }\n\n  if (isValidHslaString(value)) {\n    return parseHslaString(value);\n  }\n\n  if (isValidRgbaString(value)) {\n    return rgbaStringToHslaColor(value);\n  }\n\n  return null;\n};\n\nexport const stringToSameTypeColor = (value: string): Color => {\n  value = value.trim();\n  if (isValidHexString(value)) {\n    return value.startsWith('#') ? value : `#${value}`;\n  }\n\n  if (isValidRgbaString(value)) {\n    return parseRgbaString(value);\n  }\n\n  if (isValidHslaString(value)) {\n    return parseHslaString(value);\n  }\n\n  if (isTransparent(value)) {\n    return value;\n  }\n  return '';\n};\n\nexport const colorToSameTypeString = (color: Color): string | TransparentColor => {\n  if (typeof color === 'string' && (isValidHexString(color) || isTransparent(color))) {\n    return color;\n  }\n\n  if (isRGBColor(color)) {\n    return rgbaColorToRgbaString(color);\n  }\n\n  if (isHSLColor(color)) {\n    return hslaColorToHslaString(color);\n  }\n\n  return '';\n};\n\nexport const hexStringToRgbaColor = (hex: string): RgbaColor => {\n  hex = hex.replace('#', '');\n  const r = parseInt(hex.substring(0, 2), 16);\n  const g = parseInt(hex.substring(2, 4), 16);\n  const b = parseInt(hex.substring(4, 6), 16);\n  return { r, g, b };\n};\n\nconst rgbaColorToRgbaString = (color: RgbaColor): string => {\n  const { a, b, g, r } = color;\n  return color.a === 0 ? 'transparent' : color.a != undefined ? `rgba(${r},${g},${b},${a})` : `rgb(${r},${g},${b})`;\n};\n\nconst hslaColorToHslaString = (color: HslaColor): string => {\n  const { h, s, l, a } = color;\n  const sPerc = Math.round(s * 100);\n  const lPerc = Math.round(l * 100);\n  return color.a === 0\n    ? 'transparent'\n    : color.a != undefined\n    ? `hsla(${h},${sPerc}%,${lPerc}%,${a})`\n    : `hsl(${h},${sPerc}%,${lPerc}%)`;\n};\n\nconst hexStringToHslaColor = (hex: string): HslaColor => {\n  const rgbaString = colorToSameTypeString(hexStringToRgbaColor(hex));\n  return rgbaStringToHslaColor(rgbaString);\n};\n\nconst rgbaStringToHslaColor = (rgba: string): HslaColor => {\n  const rgbaColor = parseRgbaString(rgba);\n  const r = rgbaColor.r / 255;\n  const g = rgbaColor.g / 255;\n  const b = rgbaColor.b / 255;\n\n  const max = Math.max(r, g, b),\n    min = Math.min(r, g, b);\n  let h, s;\n  const l = (max + min) / 2;\n\n  if (max == min) {\n    h = s = 0;\n  } else {\n    const d = max - min;\n    s = l >= 0.5 ? d / (2 - (max + min)) : d / (max + min);\n    switch (max) {\n      case r:\n        h = ((g - b) / d) * 60;\n        break;\n      case g:\n        h = ((b - r) / d + 2) * 60;\n        break;\n      default:\n        h = ((r - g) / d + 4) * 60;\n        break;\n    }\n  }\n\n  const res: HslaColor = { h: Math.round(h), s, l };\n  const a = rgbaColor.a;\n  if (a != undefined) {\n    res.a = a;\n  }\n  return res;\n};\n\nconst parseRgbaString = (str: string): RgbaColor => {\n  const [r, g, b, a] = str\n    .replace(CLEAN_RGBA_REGEX, '')\n    .split(',')\n    .map(c => Number.parseFloat(c));\n  return { r, g, b, a };\n};\n\nconst parseHslaString = (str: string): HslaColor => {\n  const [h, s, l, a] = str\n    .replace(CLEAN_HSLA_REGEX, '')\n    .split(',')\n    .map(c => Number.parseFloat(c));\n  return { h, s: s / 100, l: l / 100, a };\n};\n"]},"metadata":{},"sourceType":"module"}