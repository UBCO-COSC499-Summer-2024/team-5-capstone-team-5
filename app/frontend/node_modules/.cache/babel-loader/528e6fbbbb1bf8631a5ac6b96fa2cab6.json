{"ast":null,"code":"import { eventMethodCalled } from \"./chunk-TUVJ3GI6.mjs\";\nimport { isTruthy } from \"./chunk-E6T5KUVH.mjs\";\nimport { parsePublishableKey } from \"./chunk-ZXFUQ6LY.mjs\";\nimport \"./chunk-TETGTEI2.mjs\";\nimport \"./chunk-KOH7GTJO.mjs\";\nimport \"./chunk-X2FYR5U6.mjs\";\nimport { __privateAdd, __privateGet, __privateMethod, __privateSet } from \"./chunk-UVVCWSVF.mjs\"; // src/telemetry/throttler.ts\n\nvar DEFAULT_CACHE_TTL_MS = 864e5;\n\nvar _storageKey, _cacheTtl, _generateKey, generateKey_fn, _cache, cache_get, _isValidBrowser, isValidBrowser_get;\n\nvar TelemetryEventThrottler = class {\n  constructor() {\n    /**\n     * Generates a consistent unique key for telemetry events by sorting payload properties.\n     * This ensures that payloads with identical content in different orders produce the same key.\n     */\n    __privateAdd(this, _generateKey);\n\n    __privateAdd(this, _cache);\n    /**\n     * Checks if the browser's localStorage is supported and writable.\n     *\n     * If any of these operations fail, it indicates that localStorage is either\n     * not supported or not writable (e.g., in cases where the storage is full or\n     * the browser is in a privacy mode that restricts localStorage usage).\n     */\n\n\n    __privateAdd(this, _isValidBrowser);\n\n    __privateAdd(this, _storageKey, \"clerk_telemetry_throttler\");\n\n    __privateAdd(this, _cacheTtl, DEFAULT_CACHE_TTL_MS);\n  }\n\n  isEventThrottled(payload) {\n    var _a;\n\n    if (!__privateGet(this, _isValidBrowser, isValidBrowser_get)) {\n      return false;\n    }\n\n    const now = Date.now();\n\n    const key = __privateMethod(this, _generateKey, generateKey_fn).call(this, payload);\n\n    const entry = (_a = __privateGet(this, _cache, cache_get)) == null ? void 0 : _a[key];\n\n    if (!entry) {\n      const updatedCache = { ...__privateGet(this, _cache, cache_get),\n        [key]: now\n      };\n      localStorage.setItem(__privateGet(this, _storageKey), JSON.stringify(updatedCache));\n    }\n\n    const shouldInvalidate = entry && now - entry > __privateGet(this, _cacheTtl);\n\n    if (shouldInvalidate) {\n      const updatedCache = __privateGet(this, _cache, cache_get);\n\n      delete updatedCache[key];\n      localStorage.setItem(__privateGet(this, _storageKey), JSON.stringify(updatedCache));\n    }\n\n    return !!entry;\n  }\n\n};\n_storageKey = new WeakMap();\n_cacheTtl = new WeakMap();\n_generateKey = new WeakSet();\n\ngenerateKey_fn = function (event) {\n  const {\n    sk: _sk,\n    pk: _pk,\n    payload,\n    ...rest\n  } = event;\n  const sanitizedEvent = { ...payload,\n    ...rest\n  };\n  return JSON.stringify(Object.keys({ ...payload,\n    ...rest\n  }).sort().map(key => sanitizedEvent[key]));\n};\n\n_cache = new WeakSet();\n\ncache_get = function () {\n  const cacheString = localStorage.getItem(__privateGet(this, _storageKey));\n\n  if (!cacheString) {\n    return {};\n  }\n\n  return JSON.parse(cacheString);\n};\n\n_isValidBrowser = new WeakSet();\n\nisValidBrowser_get = function () {\n  if (typeof window === \"undefined\") {\n    return false;\n  }\n\n  const storage = window.localStorage;\n\n  if (!storage) {\n    return false;\n  }\n\n  try {\n    const testKey = \"test\";\n    storage.setItem(testKey, testKey);\n    storage.removeItem(testKey);\n    return true;\n  } catch (err) {\n    const isQuotaExceededError = err instanceof DOMException && ( // Check error names for different browsers\n    err.name === \"QuotaExceededError\" || err.name === \"NS_ERROR_DOM_QUOTA_REACHED\");\n\n    if (isQuotaExceededError && storage.length > 0) {\n      storage.removeItem(__privateGet(this, _storageKey));\n    }\n\n    return false;\n  }\n}; // src/telemetry/collector.ts\n\n\nvar DEFAULT_CONFIG = {\n  samplingRate: 1,\n  maxBufferSize: 5,\n  // Production endpoint: https://clerk-telemetry.com\n  // Staging endpoint: https://staging.clerk-telemetry.com\n  // Local: http://localhost:8787\n  endpoint: \"https://clerk-telemetry.com\"\n};\n\nvar _config, _eventThrottler, _metadata, _buffer, _pendingFlush, _shouldRecord, shouldRecord_fn, _shouldBeSampled, shouldBeSampled_fn, _scheduleFlush, scheduleFlush_fn, _flush, flush_fn, _logEvent, logEvent_fn, _getSDKMetadata, getSDKMetadata_fn, _preparePayload, preparePayload_fn;\n\nvar TelemetryCollector = class {\n  constructor(options) {\n    __privateAdd(this, _shouldRecord);\n\n    __privateAdd(this, _shouldBeSampled);\n\n    __privateAdd(this, _scheduleFlush);\n\n    __privateAdd(this, _flush);\n    /**\n     * If running in debug mode, log the event and its payload to the console.\n     */\n\n\n    __privateAdd(this, _logEvent);\n    /**\n     * If in browser, attempt to lazily grab the SDK metadata from the Clerk singleton, otherwise fallback to the initially passed in values.\n     *\n     * This is necessary because the sdkMetadata can be set by the host SDK after the TelemetryCollector is instantiated.\n     */\n\n\n    __privateAdd(this, _getSDKMetadata);\n    /**\n     * Append relevant metadata from the Clerk singleton to the event payload.\n     */\n\n\n    __privateAdd(this, _preparePayload);\n\n    __privateAdd(this, _config, void 0);\n\n    __privateAdd(this, _eventThrottler, void 0);\n\n    __privateAdd(this, _metadata, {});\n\n    __privateAdd(this, _buffer, []);\n\n    __privateAdd(this, _pendingFlush, void 0);\n\n    var _a, _b, _c, _d, _e, _f;\n\n    __privateSet(this, _config, {\n      maxBufferSize: (_a = options.maxBufferSize) != null ? _a : DEFAULT_CONFIG.maxBufferSize,\n      samplingRate: (_b = options.samplingRate) != null ? _b : DEFAULT_CONFIG.samplingRate,\n      disabled: (_c = options.disabled) != null ? _c : false,\n      debug: (_d = options.debug) != null ? _d : false,\n      endpoint: DEFAULT_CONFIG.endpoint\n    });\n\n    if (!options.clerkVersion && typeof window === \"undefined\") {\n      __privateGet(this, _metadata).clerkVersion = \"\";\n    } else {\n      __privateGet(this, _metadata).clerkVersion = (_e = options.clerkVersion) != null ? _e : \"\";\n    }\n\n    __privateGet(this, _metadata).sdk = options.sdk;\n    __privateGet(this, _metadata).sdkVersion = options.sdkVersion;\n    __privateGet(this, _metadata).publishableKey = (_f = options.publishableKey) != null ? _f : \"\";\n    const parsedKey = parsePublishableKey(options.publishableKey);\n\n    if (parsedKey) {\n      __privateGet(this, _metadata).instanceType = parsedKey.instanceType;\n    }\n\n    if (options.secretKey) {\n      __privateGet(this, _metadata).secretKey = options.secretKey.substring(0, 16);\n    }\n\n    __privateSet(this, _eventThrottler, new TelemetryEventThrottler());\n  }\n\n  get isEnabled() {\n    var _a;\n\n    if (__privateGet(this, _metadata).instanceType !== \"development\") {\n      return false;\n    }\n\n    if (__privateGet(this, _config).disabled || typeof process !== \"undefined\" && isTruthy(process.env.CLERK_TELEMETRY_DISABLED)) {\n      return false;\n    }\n\n    if (typeof window !== \"undefined\" && !!((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.webdriver)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  get isDebug() {\n    return __privateGet(this, _config).debug || typeof process !== \"undefined\" && isTruthy(process.env.CLERK_TELEMETRY_DEBUG);\n  }\n\n  record(event) {\n    const preparedPayload = __privateMethod(this, _preparePayload, preparePayload_fn).call(this, event.event, event.payload);\n\n    __privateMethod(this, _logEvent, logEvent_fn).call(this, preparedPayload.event, preparedPayload);\n\n    if (!__privateMethod(this, _shouldRecord, shouldRecord_fn).call(this, preparedPayload, event.eventSamplingRate)) {\n      return;\n    }\n\n    __privateGet(this, _buffer).push(preparedPayload);\n\n    __privateMethod(this, _scheduleFlush, scheduleFlush_fn).call(this);\n  }\n\n};\n_config = new WeakMap();\n_eventThrottler = new WeakMap();\n_metadata = new WeakMap();\n_buffer = new WeakMap();\n_pendingFlush = new WeakMap();\n_shouldRecord = new WeakSet();\n\nshouldRecord_fn = function (preparedPayload, eventSamplingRate) {\n  return this.isEnabled && !this.isDebug && __privateMethod(this, _shouldBeSampled, shouldBeSampled_fn).call(this, preparedPayload, eventSamplingRate);\n};\n\n_shouldBeSampled = new WeakSet();\n\nshouldBeSampled_fn = function (preparedPayload, eventSamplingRate) {\n  const randomSeed = Math.random();\n\n  if (__privateGet(this, _eventThrottler).isEventThrottled(preparedPayload)) {\n    return false;\n  }\n\n  return randomSeed <= __privateGet(this, _config).samplingRate && (typeof eventSamplingRate === \"undefined\" || randomSeed <= eventSamplingRate);\n};\n\n_scheduleFlush = new WeakSet();\n\nscheduleFlush_fn = function () {\n  if (typeof window === \"undefined\") {\n    __privateMethod(this, _flush, flush_fn).call(this);\n\n    return;\n  }\n\n  const isBufferFull = __privateGet(this, _buffer).length >= __privateGet(this, _config).maxBufferSize;\n\n  if (isBufferFull) {\n    if (__privateGet(this, _pendingFlush)) {\n      const cancel = typeof cancelIdleCallback !== \"undefined\" ? cancelIdleCallback : clearTimeout;\n      cancel(__privateGet(this, _pendingFlush));\n    }\n\n    __privateMethod(this, _flush, flush_fn).call(this);\n\n    return;\n  }\n\n  if (__privateGet(this, _pendingFlush)) return;\n\n  if (\"requestIdleCallback\" in window) {\n    __privateSet(this, _pendingFlush, requestIdleCallback(() => {\n      __privateMethod(this, _flush, flush_fn).call(this);\n    }));\n  } else {\n    __privateSet(this, _pendingFlush, setTimeout(() => {\n      __privateMethod(this, _flush, flush_fn).call(this);\n    }, 0));\n  }\n};\n\n_flush = new WeakSet();\n\nflush_fn = function () {\n  fetch(new URL(\"/v1/event\", __privateGet(this, _config).endpoint), {\n    method: \"POST\",\n    // TODO: We send an array here with that idea that we can eventually send multiple events.\n    body: JSON.stringify({\n      events: __privateGet(this, _buffer)\n    }),\n    headers: {\n      \"Content-Type\": \"application/json\"\n    }\n  }).catch(() => void 0).then(() => {\n    __privateSet(this, _buffer, []);\n  }).catch(() => void 0);\n};\n\n_logEvent = new WeakSet();\n\nlogEvent_fn = function (event, payload) {\n  if (!this.isDebug) {\n    return;\n  }\n\n  if (typeof console.groupCollapsed !== \"undefined\") {\n    console.groupCollapsed(\"[clerk/telemetry]\", event);\n    console.log(payload);\n    console.groupEnd();\n  } else {\n    console.log(\"[clerk/telemetry]\", event, payload);\n  }\n};\n\n_getSDKMetadata = new WeakSet();\n\ngetSDKMetadata_fn = function () {\n  let sdkMetadata = {\n    name: __privateGet(this, _metadata).sdk,\n    version: __privateGet(this, _metadata).sdkVersion\n  };\n\n  if (typeof window !== \"undefined\" && window.Clerk) {\n    sdkMetadata = { ...sdkMetadata,\n      ...window.Clerk.constructor.sdkMetadata\n    };\n  }\n\n  return sdkMetadata;\n};\n\n_preparePayload = new WeakSet();\n\npreparePayload_fn = function (event, payload) {\n  var _a, _b;\n\n  const sdkMetadata = __privateMethod(this, _getSDKMetadata, getSDKMetadata_fn).call(this);\n\n  return {\n    event,\n    cv: (_a = __privateGet(this, _metadata).clerkVersion) != null ? _a : \"\",\n    it: (_b = __privateGet(this, _metadata).instanceType) != null ? _b : \"\",\n    sdk: sdkMetadata.name,\n    sdkv: sdkMetadata.version,\n    ...(__privateGet(this, _metadata).publishableKey ? {\n      pk: __privateGet(this, _metadata).publishableKey\n    } : {}),\n    ...(__privateGet(this, _metadata).secretKey ? {\n      sk: __privateGet(this, _metadata).secretKey\n    } : {}),\n    payload\n  };\n}; // src/telemetry/events/component-mounted.ts\n\n\nvar EVENT_COMPONENT_MOUNTED = \"COMPONENT_MOUNTED\";\nvar EVENT_SAMPLING_RATE = 0.1;\n\nfunction eventPrebuiltComponentMounted(component, props) {\n  var _a, _b, _c;\n\n  return {\n    event: EVENT_COMPONENT_MOUNTED,\n    eventSamplingRate: EVENT_SAMPLING_RATE,\n    payload: {\n      component,\n      appearanceProp: Boolean(props == null ? void 0 : props.appearance),\n      baseTheme: Boolean((_a = props == null ? void 0 : props.appearance) == null ? void 0 : _a.baseTheme),\n      elements: Boolean((_b = props == null ? void 0 : props.appearance) == null ? void 0 : _b.elements),\n      variables: Boolean((_c = props == null ? void 0 : props.appearance) == null ? void 0 : _c.variables)\n    }\n  };\n}\n\nfunction eventComponentMounted(component) {\n  let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return {\n    event: EVENT_COMPONENT_MOUNTED,\n    eventSamplingRate: EVENT_SAMPLING_RATE,\n    payload: {\n      component,\n      ...props\n    }\n  };\n}\n\nexport { TelemetryCollector, eventComponentMounted, eventMethodCalled, eventPrebuiltComponentMounted };","map":{"version":3,"mappings":"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","names":["DEFAULT_CACHE_TTL_MS","TelemetryEventThrottler","constructor","__privateAdd","_cache","_isValidBrowser","isEventThrottled","payload","__privateGet","isValidBrowser_get","now","Date","key","__privateMethod","_generateKey","generateKey_fn","entry","_a","cache_get","updatedCache","localStorage","setItem","_storageKey","JSON","stringify","shouldInvalidate","_cacheTtl","event","sk","_sk","pk","_pk","rest","sanitizedEvent","Object","keys","sort","map","cacheString","getItem","parse","window","storage","testKey","removeItem","err","isQuotaExceededError","DOMException","name","length","DEFAULT_CONFIG","samplingRate","maxBufferSize","endpoint","TelemetryCollector","options","__privateSet","_config","_b","disabled","_c","debug","_d","clerkVersion","_metadata","_e","sdk","sdkVersion","publishableKey","_f","parsedKey","parsePublishableKey","instanceType","secretKey","substring","_eventThrottler","process","isTruthy","env","CLERK_TELEMETRY_DISABLED","navigator","webdriver","CLERK_TELEMETRY_DEBUG","record","preparedPayload","_preparePayload","preparePayload_fn","_logEvent","logEvent_fn","_shouldRecord","shouldRecord_fn","eventSamplingRate","_buffer","push","_scheduleFlush","scheduleFlush_fn","_pendingFlush","isEnabled","isDebug","_shouldBeSampled","shouldBeSampled_fn","randomSeed","Math","random","_flush","flush_fn","isBufferFull","cancel","cancelIdleCallback","clearTimeout","requestIdleCallback","setTimeout","fetch","URL","method","body","events","headers","catch","then","console","groupCollapsed","log","groupEnd","_getSDKMetadata","getSDKMetadata_fn","sdkMetadata","version","Clerk","cv","it","sdkv","EVENT_COMPONENT_MOUNTED","EVENT_SAMPLING_RATE","eventPrebuiltComponentMounted","component","props","appearanceProp","Boolean","appearance","baseTheme","elements","variables","eventComponentMounted"],"sources":["/Users/jaybhullar/Desktop/team-5-capstone-team-5/app/frontend/node_modules/@clerk/shared/src/telemetry/throttler.ts","/Users/jaybhullar/Desktop/team-5-capstone-team-5/app/frontend/node_modules/@clerk/shared/src/telemetry/collector.ts","/Users/jaybhullar/Desktop/team-5-capstone-team-5/app/frontend/node_modules/@clerk/shared/src/telemetry/events/component-mounted.ts"],"sourcesContent":["import type { TelemetryEvent } from '@clerk/types';\n\ntype TtlInMilliseconds = number;\n\nconst DEFAULT_CACHE_TTL_MS = 86400000; // 24 hours\n\n/**\n * Manages throttling for telemetry events using the browser's localStorage to\n * mitigate event flooding in frequently executed code paths.\n */\nexport class TelemetryEventThrottler {\n  #storageKey = 'clerk_telemetry_throttler';\n  #cacheTtl = DEFAULT_CACHE_TTL_MS;\n\n  isEventThrottled(payload: TelemetryEvent): boolean {\n    if (!this.#isValidBrowser) {\n      return false;\n    }\n\n    const now = Date.now();\n    const key = this.#generateKey(payload);\n    const entry = this.#cache?.[key];\n\n    if (!entry) {\n      const updatedCache = {\n        ...this.#cache,\n        [key]: now,\n      };\n\n      localStorage.setItem(this.#storageKey, JSON.stringify(updatedCache));\n    }\n\n    const shouldInvalidate = entry && now - entry > this.#cacheTtl;\n    if (shouldInvalidate) {\n      const updatedCache = this.#cache;\n      delete updatedCache[key];\n\n      localStorage.setItem(this.#storageKey, JSON.stringify(updatedCache));\n    }\n\n    return !!entry;\n  }\n\n  /**\n   * Generates a consistent unique key for telemetry events by sorting payload properties.\n   * This ensures that payloads with identical content in different orders produce the same key.\n   */\n  #generateKey(event: TelemetryEvent): string {\n    const { sk: _sk, pk: _pk, payload, ...rest } = event;\n\n    const sanitizedEvent = {\n      ...payload,\n      ...rest,\n    };\n\n    return JSON.stringify(\n      Object.keys({\n        ...payload,\n        ...rest,\n      })\n        .sort()\n        .map(key => sanitizedEvent[key]),\n    );\n  }\n\n  get #cache(): Record<string, TtlInMilliseconds> | undefined {\n    const cacheString = localStorage.getItem(this.#storageKey);\n\n    if (!cacheString) {\n      return {};\n    }\n\n    return JSON.parse(cacheString);\n  }\n\n  /**\n   * Checks if the browser's localStorage is supported and writable.\n   *\n   * If any of these operations fail, it indicates that localStorage is either\n   * not supported or not writable (e.g., in cases where the storage is full or\n   * the browser is in a privacy mode that restricts localStorage usage).\n   */\n  get #isValidBrowser(): boolean {\n    if (typeof window === 'undefined') {\n      return false;\n    }\n\n    const storage = window.localStorage;\n    if (!storage) {\n      return false;\n    }\n\n    try {\n      const testKey = 'test';\n      storage.setItem(testKey, testKey);\n      storage.removeItem(testKey);\n\n      return true;\n    } catch (err: unknown) {\n      const isQuotaExceededError =\n        err instanceof DOMException &&\n        // Check error names for different browsers\n        (err.name === 'QuotaExceededError' || err.name === 'NS_ERROR_DOM_QUOTA_REACHED');\n\n      if (isQuotaExceededError && storage.length > 0) {\n        storage.removeItem(this.#storageKey);\n      }\n\n      return false;\n    }\n  }\n}\n","/**\n * The `TelemetryCollector` class handles collection of telemetry events from Clerk SDKs. Telemetry is opt-out and can be disabled by setting a CLERK_TELEMETRY_DISABLED environment variable.\n * The `ClerkProvider` also accepts a `telemetry` prop that will be passed to the collector during initialization:\n *\n * ```jsx\n * <ClerkProvider telemetry={false}>\n *    ...\n * </ClerkProvider>\n * ```\n *\n * For more information, please see the telemetry documentation page: https://clerk.com/docs/telemetry\n */\nimport type {\n  InstanceType,\n  TelemetryCollector as TelemetryCollectorInterface,\n  TelemetryEvent,\n  TelemetryEventRaw,\n} from '@clerk/types';\n\nimport { parsePublishableKey } from '../keys';\nimport { isTruthy } from '../underscore';\nimport { TelemetryEventThrottler } from './throttler';\nimport type { TelemetryCollectorOptions } from './types';\n\ntype TelemetryCollectorConfig = Pick<\n  TelemetryCollectorOptions,\n  'samplingRate' | 'disabled' | 'debug' | 'maxBufferSize'\n> & {\n  endpoint: string;\n};\n\ntype TelemetryMetadata = Required<\n  Pick<TelemetryCollectorOptions, 'clerkVersion' | 'sdk' | 'sdkVersion' | 'publishableKey' | 'secretKey'>\n> & {\n  /**\n   * The instance type, derived from the provided publishableKey.\n   */\n  instanceType: InstanceType;\n};\n\nconst DEFAULT_CONFIG: Partial<TelemetryCollectorConfig> = {\n  samplingRate: 1,\n  maxBufferSize: 5,\n  // Production endpoint: https://clerk-telemetry.com\n  // Staging endpoint: https://staging.clerk-telemetry.com\n  // Local: http://localhost:8787\n  endpoint: 'https://clerk-telemetry.com',\n};\n\nexport class TelemetryCollector implements TelemetryCollectorInterface {\n  #config: Required<TelemetryCollectorConfig>;\n  #eventThrottler: TelemetryEventThrottler;\n  #metadata: TelemetryMetadata = {} as TelemetryMetadata;\n  #buffer: TelemetryEvent[] = [];\n  #pendingFlush: any;\n\n  constructor(options: TelemetryCollectorOptions) {\n    this.#config = {\n      maxBufferSize: options.maxBufferSize ?? DEFAULT_CONFIG.maxBufferSize,\n      samplingRate: options.samplingRate ?? DEFAULT_CONFIG.samplingRate,\n      disabled: options.disabled ?? false,\n      debug: options.debug ?? false,\n      endpoint: DEFAULT_CONFIG.endpoint,\n    } as Required<TelemetryCollectorConfig>;\n\n    if (!options.clerkVersion && typeof window === 'undefined') {\n      // N/A in a server environment\n      this.#metadata.clerkVersion = '';\n    } else {\n      this.#metadata.clerkVersion = options.clerkVersion ?? '';\n    }\n\n    // We will try to grab the SDK data lazily when an event is triggered, so it should always be defined once the event is sent.\n    this.#metadata.sdk = options.sdk!;\n    this.#metadata.sdkVersion = options.sdkVersion!;\n\n    this.#metadata.publishableKey = options.publishableKey ?? '';\n\n    const parsedKey = parsePublishableKey(options.publishableKey);\n    if (parsedKey) {\n      this.#metadata.instanceType = parsedKey.instanceType;\n    }\n\n    if (options.secretKey) {\n      // Only send the first 16 characters of the secret key to to avoid sending the full key. We can still query against the partial key.\n      this.#metadata.secretKey = options.secretKey.substring(0, 16);\n    }\n\n    this.#eventThrottler = new TelemetryEventThrottler();\n  }\n\n  get isEnabled(): boolean {\n    if (this.#metadata.instanceType !== 'development') {\n      return false;\n    }\n\n    // In browser or client environments, we most likely pass the disabled option to the collector, but in environments\n    // where environment variables are available we also check for `CLERK_TELEMETRY_DISABLED`.\n    if (this.#config.disabled || (typeof process !== 'undefined' && isTruthy(process.env.CLERK_TELEMETRY_DISABLED))) {\n      return false;\n    }\n\n    // navigator.webdriver is a property generally set by headless browsers that are running in an automated testing environment.\n    // Data from these environments is not meaningful for us and has the potential to produce a large volume of events, so we disable\n    // collection in this case. (ref: https://developer.mozilla.org/en-US/docs/Web/API/Navigator/webdriver)\n    if (typeof window !== 'undefined' && !!window?.navigator?.webdriver) {\n      return false;\n    }\n\n    return true;\n  }\n\n  get isDebug(): boolean {\n    return this.#config.debug || (typeof process !== 'undefined' && isTruthy(process.env.CLERK_TELEMETRY_DEBUG));\n  }\n\n  record(event: TelemetryEventRaw): void {\n    const preparedPayload = this.#preparePayload(event.event, event.payload);\n\n    this.#logEvent(preparedPayload.event, preparedPayload);\n\n    if (!this.#shouldRecord(preparedPayload, event.eventSamplingRate)) {\n      return;\n    }\n\n    this.#buffer.push(preparedPayload);\n\n    this.#scheduleFlush();\n  }\n\n  #shouldRecord(preparedPayload: TelemetryEvent, eventSamplingRate?: number) {\n    return this.isEnabled && !this.isDebug && this.#shouldBeSampled(preparedPayload, eventSamplingRate);\n  }\n\n  #shouldBeSampled(preparedPayload: TelemetryEvent, eventSamplingRate?: number) {\n    const randomSeed = Math.random();\n\n    if (this.#eventThrottler.isEventThrottled(preparedPayload)) {\n      return false;\n    }\n\n    return (\n      randomSeed <= this.#config.samplingRate &&\n      (typeof eventSamplingRate === 'undefined' || randomSeed <= eventSamplingRate)\n    );\n  }\n\n  #scheduleFlush(): void {\n    // On the server, we want to flush immediately as we have less guarantees about the lifecycle of the process\n    if (typeof window === 'undefined') {\n      this.#flush();\n      return;\n    }\n\n    const isBufferFull = this.#buffer.length >= this.#config.maxBufferSize;\n    if (isBufferFull) {\n      // If the buffer is full, flush immediately to make sure we minimize the chance of event loss.\n      // Cancel any pending flushes as we're going to flush immediately\n      if (this.#pendingFlush) {\n        const cancel = typeof cancelIdleCallback !== 'undefined' ? cancelIdleCallback : clearTimeout;\n        cancel(this.#pendingFlush);\n      }\n      this.#flush();\n      return;\n    }\n\n    // If we have a pending flush, do nothing\n    if (this.#pendingFlush) return;\n\n    if ('requestIdleCallback' in window) {\n      this.#pendingFlush = requestIdleCallback(() => {\n        this.#flush();\n      });\n    } else {\n      // This is not an ideal solution, but it at least waits until the next tick\n      this.#pendingFlush = setTimeout(() => {\n        this.#flush();\n      }, 0);\n    }\n  }\n\n  #flush(): void {\n    fetch(new URL('/v1/event', this.#config.endpoint), {\n      method: 'POST',\n      // TODO: We send an array here with that idea that we can eventually send multiple events.\n      body: JSON.stringify({\n        events: this.#buffer,\n      }),\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    })\n      .catch(() => void 0)\n      .then(() => {\n        this.#buffer = [];\n      })\n      .catch(() => void 0);\n  }\n\n  /**\n   * If running in debug mode, log the event and its payload to the console.\n   */\n  #logEvent(event: TelemetryEvent['event'], payload: Record<string, any>) {\n    if (!this.isDebug) {\n      return;\n    }\n\n    if (typeof console.groupCollapsed !== 'undefined') {\n      console.groupCollapsed('[clerk/telemetry]', event);\n      console.log(payload);\n      console.groupEnd();\n    } else {\n      console.log('[clerk/telemetry]', event, payload);\n    }\n  }\n\n  /**\n   * If in browser, attempt to lazily grab the SDK metadata from the Clerk singleton, otherwise fallback to the initially passed in values.\n   *\n   * This is necessary because the sdkMetadata can be set by the host SDK after the TelemetryCollector is instantiated.\n   */\n  #getSDKMetadata() {\n    let sdkMetadata = {\n      name: this.#metadata.sdk,\n      version: this.#metadata.sdkVersion,\n    };\n\n    // @ts-expect-error -- The global window.Clerk type is declared in clerk-js, but we can't rely on that here\n    if (typeof window !== 'undefined' && window.Clerk) {\n      // @ts-expect-error -- The global window.Clerk type is declared in clerk-js, but we can't rely on that here\n      sdkMetadata = { ...sdkMetadata, ...window.Clerk.constructor.sdkMetadata };\n    }\n\n    return sdkMetadata;\n  }\n\n  /**\n   * Append relevant metadata from the Clerk singleton to the event payload.\n   */\n  #preparePayload(event: TelemetryEvent['event'], payload: TelemetryEvent['payload']): TelemetryEvent {\n    const sdkMetadata = this.#getSDKMetadata();\n\n    return {\n      event,\n      cv: this.#metadata.clerkVersion ?? '',\n      it: this.#metadata.instanceType ?? '',\n      sdk: sdkMetadata.name,\n      sdkv: sdkMetadata.version,\n      ...(this.#metadata.publishableKey ? { pk: this.#metadata.publishableKey } : {}),\n      ...(this.#metadata.secretKey ? { sk: this.#metadata.secretKey } : {}),\n      payload,\n    };\n  }\n}\n","import type { TelemetryEventRaw } from '@clerk/types';\n\nconst EVENT_COMPONENT_MOUNTED = 'COMPONENT_MOUNTED' as const;\nconst EVENT_SAMPLING_RATE = 0.1;\n\ntype ComponentMountedBase = {\n  component: string;\n};\n\ntype EventPrebuiltComponentMounted = ComponentMountedBase & {\n  appearanceProp: boolean;\n  elements: boolean;\n  variables: boolean;\n  baseTheme: boolean;\n};\n\ntype EventComponentMounted = ComponentMountedBase & {\n  [key: string]: boolean | string;\n};\n\n/**\n * Helper function for `telemetry.record()`. Create a consistent event object for when a prebuilt (AIO) component is mounted.\n *\n * @param component - The name of the component.\n * @param props - The props passed to the component. Will be filtered to a known list of props.\n *\n * @example\n * telemetry.record(eventPrebuiltComponentMounted('SignUp', props));\n */\nexport function eventPrebuiltComponentMounted(\n  component: string,\n  props?: Record<string, any>,\n): TelemetryEventRaw<EventPrebuiltComponentMounted> {\n  return {\n    event: EVENT_COMPONENT_MOUNTED,\n    eventSamplingRate: EVENT_SAMPLING_RATE,\n    payload: {\n      component,\n      appearanceProp: Boolean(props?.appearance),\n      baseTheme: Boolean(props?.appearance?.baseTheme),\n      elements: Boolean(props?.appearance?.elements),\n      variables: Boolean(props?.appearance?.variables),\n    },\n  };\n}\n\n/**\n * Helper function for `telemetry.record()`. Create a consistent event object for when a component is mounted. Use `eventPrebuiltComponentMounted` for prebuilt components.\n *\n * **Caution:** Filter the `props` you pass to this function to avoid sending too much data.\n *\n * @param component - The name of the component.\n * @param props - The props passed to the component. Ideally you only pass a handful of props here.\n *\n * @example\n * telemetry.record(eventComponentMounted('SignUp', props));\n */\nexport function eventComponentMounted(\n  component: string,\n  props: Record<string, string | boolean> = {},\n): TelemetryEventRaw<EventComponentMounted> {\n  return {\n    event: EVENT_COMPONENT_MOUNTED,\n    eventSamplingRate: EVENT_SAMPLING_RATE,\n    payload: {\n      component,\n      ...props,\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module"}